#!/usr/bin/env python
#
#  Backup client program that wraps rsync and allows the server to control some
#  options which rsync doesn't.  It can also run some plugins to do things like
#  database backups.

import os
import sys
import shlex
import syslog
syslog.openlog(os.path.basename(sys.argv[0]))


def get_program_path():
    '''Get the full path to the Python program that is running.
    This is used for re-invoking the program under sudo, so it needs to track
    down the path to the program that was run, by following any relative
    pathing or searching the path.
    '''
    return os.path.abspath(sys.argv[0])


def length_read(fp, max_length=10000):
    '''Read a string from `fp`, the string must start with a length and ":".
    Data is read from `fp`, with the first 10 characters (or less) expected
    to be an ASCII decimal string representing the length of the remainder
    of the string and a colon.  For example: "5:hello", or "000000002:hi".
    '''
    data = ''
    while len(data) < 10 and ':' not in data:
        tmp = fp.read(1)
        if not tmp:
            raise ValueError('Invalid input to length_read')
        data += tmp

    length, data = data.split(':', 1)
    length = int(length)

    if length > max_length:
        raise ValueError(
            'Requested read length {0} greater than max {1}'
            .format(length, max_length))

    while len(data) < length:
        tmp = fp.read(length - len(data))
        if not tmp:
            raise ValueError('Incomplete read in length_read')
        data += tmp

    return data


def debug(msg):
    syslog.syslog(msg)
    print msg


def run_as_root():
    '''If this process is not being run as root, re-exec it under sudo.
    If already running as root, just return.
    '''
    if os.getuid() != 0:
        os.execvp(
            'sudo', ['sudo', '-n', get_program_path()] + list(sys.argv[1:]))
        debug('Failed to exec sudo, probably need to fix sudoers')
        sys.exit(1)


def parse_option_bwlimit(s):
    '''Parse an "bwlimit=DDDD" option.
    Return the integer bandwidth limit.
    '''
    bwlimit = int(s.split('=', 1)[-1])
    max_limit = 10000000
    if bwlimit > max_limit:
        raise ValueError('Bandwidth limit too high, max={0}'.format(max_limit))
    return bwlimit


def is_whitelisted_fs(fs):
    '''Is the specified file-system type worth backing up?
    This is the fstype as read from /proc/mounts in the third column.
    '''
    return fs in ['btrfs', 'zfs', 'ext2', 'ext3', 'ext4', 'xfs', 'jfs']


def run_rsync_backup(options):
    '''Run the rsync command for doing backups, with the specified options.
    '''
    rsync_arguments = [
        'rsync',
        '--server',
        '--sender',
        '-lHogDtpre.i',
        '--ignore-errors',
        '--numeric-ids',
        '--inplace',
    ]

    for option in options:
        if option == 'compression':
            rsync_arguments.append('--compression')
        if option.starts_with('bwlimit='):
            rsync_arguments.append(
                '--bwlimit={0}'.format(parse_option_bwlimit(option)))

    rsync_arguments.append('.')
    rsync_arguments.append('/')

    os.execvp('rsync', rsync_arguments)
    debug('Error executing rsync command.')
    sys.exit(250)


def parse_ssh_command(s):
    found_args = []
    for option in shlex.split(s)[1:]:
        if option.startswith('--bwlimit='):
            rate = int(option[10:])
            found_args.append('--bwlimit=%d' % rate)
        elif option == '--compression':
            found_args.append('--compression')
        elif option.startswith('-') and not option.startswith('--'):
            if 'z' in option[1:]:
                found_args.append('--compression')

    return found_args


def main():
    run_as_root()
    run_rsync_backup(
        parse_ssh_command(os.environ.get('SSH_ORIGINAL_COMMAND')))

if __name__ == '__main__':
    main()
